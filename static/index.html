<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>VectoryTones</title>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background: #0f1117; color: #e0e0e0; height: 100vh; display: flex; flex-direction: column; }
  header { background: #1a1d27; padding: 12px 24px; border-bottom: 1px solid #2a2d3a; display: flex; align-items: center; gap: 12px; position: relative; }
  header h1 { font-size: 1.3rem; color: #7c8aff; }
  header span { font-size: 0.85rem; color: #888; }
  .layout { display: flex; flex: 1; overflow: hidden; }

  /* Burger menu */
  .burger-menu { position: absolute; left: 12px; top: 50%; transform: translateY(-50%); }
  .burger-btn { width: 32px; height: 32px; background: transparent; border: 1px solid #2a2d3a; border-radius: 4px; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 4px; padding: 0; transition: all 0.2s; }
  .burger-btn:hover { background: #252940; border-color: #7c8aff; }
  .burger-btn span { display: block; width: 18px; height: 2px; background: #aaa; transition: all 0.2s; }
  .burger-btn:hover span { background: #7c8aff; }
  .burger-dropdown { position: absolute; top: 40px; left: 0; background: #1a1d27; border: 1px solid #2a2d3a; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.5); min-width: 220px; z-index: 1000; display: none; }
  .burger-dropdown.show { display: block; }
  .burger-section { padding: 8px 0; border-bottom: 1px solid #2a2d3a; }
  .burger-section:last-child { border-bottom: none; }
  .burger-section-title { font-size: 0.7rem; text-transform: uppercase; letter-spacing: 0.05em; color: #666; padding: 8px 16px 4px; }
  .burger-item { padding: 10px 16px; cursor: pointer; font-size: 0.85rem; color: #aaa; transition: all 0.15s; display: flex; align-items: center; gap: 8px; }
  .burger-item:hover { background: #252940; color: #e0e0e0; }
  .burger-status { font-size: 0.7rem; color: #666; padding: 4px 16px 8px; }
  header h1 { margin-left: 48px; }

  /* Left panel ‚Äì clip list */
  .panel-left { width: 240px; border-right: 1px solid #2a2d3a; overflow-y: auto; background: #14161e; display: flex; flex-direction: column; position: relative; }
  .panel-left h2 { font-size: 0.85rem; text-transform: uppercase; letter-spacing: 0.05em; color: #888; padding: 12px 16px 8px; }
  .sort-bar { padding: 8px 16px 12px; border-bottom: 1px solid #2a2d3a; }
  .sort-mode { display: flex; gap: 10px; margin-bottom: 6px; }
  .sort-mode label { font-size: 0.75rem; color: #aaa; cursor: pointer; display: flex; align-items: center; gap: 3px; }
  .sort-mode input[type="radio"] { accent-color: #7c8aff; margin: 0; }
  .sort-bar .sort-label { font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.05em; color: #888; display: block; margin-bottom: 4px; }
  .sort-bar input[type="text"] { width: 100%; padding: 6px 8px; border: 1px solid #2a2d3a; border-radius: 4px; background: #1a1d27; color: #e0e0e0; font-size: 0.85rem; outline: none; }
  .sort-bar input[type="text"]:focus { border-color: #7c8aff; }
  .sort-bar input[type="text"]::placeholder { color: #555; }
  .sort-bar .sort-status { font-size: 0.7rem; color: #666; margin-top: 4px; }
  #clip-list { overflow-y: auto; flex: 1; }
  .clip-item { padding: 10px 16px; cursor: pointer; font-size: 0.9rem; border-bottom: 1px solid #1e2030; transition: background 0.15s; border-left: 3px solid transparent; }
  .clip-item:hover { background: #1e2030; }
  .clip-item.active { background: #252940; color: #7c8aff; }
  .clip-item.labeled-good { border-left-color: #4caf50; background: rgba(76, 175, 80, 0.08); }
  .clip-item.labeled-bad { border-left-color: #f44336; background: rgba(244, 67, 54, 0.08); }
  .clip-item.labeled-good.active { background: #252940; border-left-color: #4caf50; }
  .clip-item.labeled-bad.active { background: #252940; border-left-color: #f44336; }
  .clip-item .sub { font-size: 0.75rem; color: #666; margin-top: 2px; }
  .clip-item .sim { font-size: 0.7rem; color: #7c8aff; float: right; margin-top: 2px; }

  /* Stripe overview */
  .stripe-overview { position: absolute; right: 0; top: 0; bottom: 0; width: 20px; background: #1a1d27; border-left: 1px solid #2a2d3a; cursor: pointer; }
  .stripe-container { position: relative; height: 100%; }
  .stripe-dot { position: absolute; left: 50%; width: 6px; height: 6px; border-radius: 50%; }
  .stripe-dot.good { background: #4caf50; transform: translateX(-25%); }
  .stripe-dot.bad { background: #f44336; transform: translateX(-75%); }
  .stripe-threshold { position: absolute; left: 0; right: 0; height: 2px; background: #7c8aff; }
  .stripe-threshold::before { content: ''; position: absolute; left: 0; top: 50%; transform: translateY(-50%); width: 0; height: 0; border-top: 4px solid transparent; border-bottom: 4px solid transparent; border-left: 6px solid #7c8aff; }
  .stripe-threshold::after { content: ''; position: absolute; right: 0; top: 50%; transform: translateY(-50%); width: 0; height: 0; border-top: 4px solid transparent; border-bottom: 4px solid transparent; border-right: 6px solid #7c8aff; }

  /* Center panel ‚Äì player */
  .panel-center { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 20px; padding: 32px; }
  .panel-center.empty { color: #555; font-size: 1rem; }
  .meta { text-align: center; }
  .meta h2 { font-size: 1.5rem; color: #7c8aff; margin-bottom: 8px; }
  .meta p { font-size: 0.85rem; color: #888; margin: 2px 0; }

  /* Waveform canvas */
  #waveform-canvas { border: 1px solid #2a2d3a; border-radius: 8px; background: #1a1d27; }

  audio { width: 320px; }

  /* Metadata grid */
  .metadata-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px 24px;
    width: 600px;
    background: #1a1d27;
    padding: 16px 20px;
    border-radius: 8px;
    border: 1px solid #2a2d3a;
  }
  .metadata-item { display: flex; flex-direction: column; gap: 4px; }
  .metadata-label { font-size: 0.7rem; color: #888; text-transform: uppercase; letter-spacing: 0.05em; }
  .metadata-value { font-size: 0.9rem; color: #e0e0e0; font-family: monospace; }
  .metadata-md5 { font-size: 0.75rem; word-break: break-all; }

  .vote-buttons { display: flex; gap: 16px; }
  .vote-buttons button { padding: 10px 28px; border: 2px solid; border-radius: 8px; font-size: 1rem; cursor: pointer; background: transparent; transition: all 0.15s; }
  .btn-good { color: #4caf50; border-color: #4caf50; }
  .btn-good:hover, .btn-good.voted { background: #4caf50; color: #fff; }
  .btn-bad { color: #f44336; border-color: #f44336; }
  .btn-bad:hover, .btn-bad.voted { background: #f44336; color: #fff; }

  /* Right panel ‚Äì votes */
  .panel-right { width: 240px; border-left: 1px solid #2a2d3a; overflow-y: auto; background: #14161e; display: flex; flex-direction: column; }
  .vote-section { flex: 1; overflow-y: auto; padding: 12px 16px; }
  .vote-section + .vote-section { border-top: 1px solid #2a2d3a; }
  .vote-section h3 { font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 8px; }
  .vote-section h3.good { color: #4caf50; }
  .vote-section h3.bad { color: #f44336; }
  .vote-entry { padding: 6px 0; font-size: 0.85rem; cursor: pointer; color: #bbb; }
  .vote-entry:hover { color: #fff; }

  /* Import/Export bar */
  .label-io { display: flex; gap: 8px; padding: 12px 16px; border-bottom: 1px solid #2a2d3a; }
  .label-io button { flex: 1; padding: 6px 0; border: 1px solid #2a2d3a; border-radius: 4px; background: #1a1d27; color: #aaa; font-size: 0.75rem; cursor: pointer; transition: background 0.15s, color 0.15s; }
  .label-io button:hover { background: #252940; color: #e0e0e0; }
  .label-io-status { font-size: 0.7rem; color: #666; padding: 0 16px 8px; }

  /* Dataset management */
  .dataset-welcome { display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 24px; padding: 48px; max-width: 600px; margin: 0 auto; text-align: center; }
  .dataset-welcome h2 { font-size: 1.8rem; color: #7c8aff; margin-bottom: 8px; }
  .dataset-welcome p { font-size: 1rem; color: #aaa; margin-bottom: 16px; }
  .dataset-options { display: flex; flex-direction: column; gap: 12px; width: 100%; }
  .dataset-option { padding: 16px 20px; border: 2px solid #2a2d3a; border-radius: 8px; background: #1a1d27; color: #e0e0e0; cursor: pointer; transition: all 0.2s; text-align: left; }
  .dataset-option:hover { border-color: #7c8aff; background: #1e2030; }
  .dataset-option h3 { font-size: 1.1rem; margin-bottom: 4px; color: #7c8aff; }
  .dataset-option p { font-size: 0.85rem; color: #888; margin: 0; }
  .dataset-progress { width: 100%; max-width: 500px; }
  .progress-bar { width: 100%; height: 24px; background: #1a1d27; border: 1px solid #2a2d3a; border-radius: 4px; overflow: hidden; position: relative; }
  .progress-fill { height: 100%; background: linear-gradient(90deg, #7c8aff, #a0aaff); transition: width 0.3s; }
  .progress-text { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 0.75rem; color: #fff; font-weight: bold; }
  .progress-message { font-size: 0.85rem; color: #aaa; margin-top: 8px; text-align: center; }
  .demo-datasets { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px; width: 100%; margin-top: 16px; }
  .demo-dataset { padding: 16px; border: 2px solid #2a2d3a; border-radius: 8px; background: #1a1d27; cursor: pointer; transition: all 0.2s; text-align: center; }
  .demo-dataset:hover { border-color: #7c8aff; background: #1e2030; }
  .demo-dataset.ready { border-color: #4caf50; }
  .demo-dataset h4 { font-size: 1rem; color: #7c8aff; margin-bottom: 4px; text-transform: capitalize; }
  .demo-dataset p { font-size: 0.75rem; color: #888; margin: 0; }
  .demo-dataset .ready-badge { display: inline-block; margin-top: 4px; padding: 2px 8px; background: #4caf50; color: #fff; font-size: 0.7rem; border-radius: 4px; }
  .back-button { margin-top: 16px; padding: 8px 24px; border: 1px solid #2a2d3a; border-radius: 4px; background: #1a1d27; color: #aaa; cursor: pointer; transition: all 0.2s; }
  .back-button:hover { background: #252940; color: #e0e0e0; }
  .dataset-bar { padding: 12px 16px; border-bottom: 1px solid #2a2d3a; display: flex; justify-content: space-between; align-items: center; }
  .dataset-bar .dataset-info { font-size: 0.85rem; color: #aaa; }
  .dataset-bar button { padding: 6px 16px; border: 1px solid #2a2d3a; border-radius: 4px; background: #1a1d27; color: #aaa; font-size: 0.75rem; cursor: pointer; transition: all 0.2s; }
  .dataset-bar button:hover { background: #252940; color: #e0e0e0; }
</style>
</head>
<body>
<header>
  <div class="burger-menu">
    <button class="burger-btn" id="burger-btn">
      <span></span>
      <span></span>
      <span></span>
    </button>
    <div class="burger-dropdown" id="burger-dropdown">
      <div class="burger-section">
        <div class="burger-section-title">Dataset</div>
        <div class="burger-item" id="menu-dataset-export">Export Dataset</div>
        <div class="burger-item" id="menu-dataset-change">Change Dataset</div>
      </div>
      <div class="burger-section">
        <div class="burger-section-title">Labels</div>
        <div class="burger-item" id="menu-labels-export">Export Labels</div>
        <div class="burger-item" id="menu-labels-import">Import Labels</div>
        <div class="burger-status" id="menu-labels-status"></div>
      </div>
      <div class="burger-section">
        <div class="burger-section-title">Detector</div>
        <div class="burger-item" id="menu-detector-import">Import Detector</div>
        <div class="burger-item" id="menu-detector-export">Export Detector</div>
        <div class="burger-status" id="menu-detector-status"></div>
      </div>
    </div>
  </div>
  <h1>VectoryTones</h1>
  <span>Sound clip explorer with vector embeddings</span>
</header>
<div class="layout">
  <!-- Left panel -->
  <div class="panel-left" id="left-panel">
    <div class="dataset-bar" id="dataset-bar" style="display:none">
      <span class="dataset-info" id="dataset-info">No dataset loaded</span>
    </div>
    <h2>Clips</h2>
    <div class="sort-bar" id="sort-bar">
      <span class="sort-label">Sort</span>
      <div class="sort-mode">
        <label><input type="radio" name="sort-mode" value="text" checked> Text</label>
        <label><input type="radio" name="sort-mode" value="learned" id="learned-radio"> Learn</label>
        <label><input type="radio" name="sort-mode" value="load" id="load-radio"> Load</label>
      </div>
      <div id="text-sort-wrap">
        <input type="text" id="text-sort" placeholder='e.g. "high pitched beep"'>
      </div>
      <div id="load-sort-wrap" style="display:none">
        <button id="load-detector-btn" style="width:100%; padding:6px; background:#7c8aff; color:#fff; border:none; border-radius:4px; cursor:pointer; font-size:0.85rem;">Load Detector</button>
        <input type="file" id="load-detector-file" accept=".json" style="display:none">
      </div>
      <span class="sort-label" style="margin-top:8px">Select</span>
      <div class="sort-mode">
        <label><input type="radio" name="select-mode" value="good" checked> Good</label>
        <label><input type="radio" name="select-mode" value="hard"> Hard</label>
      </div>
      <span class="sort-label" style="margin-top:8px">Inclusion</span>
      <div style="display:flex; align-items:center; gap:8px; margin-top:4px">
        <span style="font-size:0.7rem; color:#888">-10</span>
        <input type="range" id="inclusion-slider" min="-10" max="10" value="0" step="1" style="flex:1; accent-color:#7c8aff">
        <span style="font-size:0.7rem; color:#888">+10</span>
      </div>
      <div style="text-align:center; font-size:0.75rem; color:#aaa; margin-top:2px">
        <span id="inclusion-value">0</span>
      </div>
      <div id="sort-status" class="sort-status"></div>
    </div>
    <div id="clip-list"></div>
    <div class="stripe-overview" id="stripe-overview">
      <div class="stripe-container" id="stripe-container"></div>
    </div>
  </div>

  <!-- Center panel -->
  <div class="panel-center" id="center">
    <div class="dataset-welcome" id="dataset-welcome">
      <div>
        <h2>Welcome to VectoryTones</h2>
        <p>Load or generate a dataset to get started</p>
      </div>
      <div class="dataset-options" id="dataset-options">
        <button class="dataset-option" id="load-file-btn">
          <h3>üìÅ Load from File</h3>
          <p>Load a previously saved dataset file (.pkl)</p>
        </button>
        <button class="dataset-option" id="load-folder-btn">
          <h3>üéµ Generate from Folder</h3>
          <p>Process audio files from a folder on your computer</p>
        </button>
        <button class="dataset-option" id="load-demo-btn">
          <h3>üéØ Load Demo Dataset</h3>
          <p>Choose from pre-configured ESC-50 datasets</p>
        </button>
      </div>
      <div class="dataset-progress" id="dataset-progress" style="display:none">
        <div class="progress-bar">
          <div class="progress-fill" id="progress-fill" style="width:0%"></div>
          <div class="progress-text" id="progress-text">0%</div>
        </div>
        <div class="progress-message" id="progress-message">Loading...</div>
      </div>
      <div class="demo-datasets" id="demo-datasets" style="display:none"></div>
      <button class="back-button" id="back-button" style="display:none">Back</button>
    </div>
  </div>
  <input type="file" id="file-input" accept=".pkl" style="display:none">
  <input type="file" id="folder-input" webkitdirectory directory multiple style="display:none">

  <!-- Right panel -->
  <div class="panel-right">
    <input type="file" id="import-file" accept=".json" style="display:none">
    <div class="vote-section">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
        <h3 class="good" style="margin: 0;">Good</h3>
        <select id="good-sort-mode" style="font-size: 0.75rem; padding: 2px 4px; background: #2a2a2a; color: #aaa; border: 1px solid #444; border-radius: 3px;">
          <option value="clip">By Clip#</option>
          <option value="order">By Click</option>
        </select>
      </div>
      <div id="good-list"></div>
    </div>
    <div class="vote-section">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
        <h3 class="bad" style="margin: 0;">Bad</h3>
        <select id="bad-sort-mode" style="font-size: 0.75rem; padding: 2px 4px; background: #2a2a2a; color: #aaa; border: 1px solid #444; border-radius: 3px;">
          <option value="clip">By Clip#</option>
          <option value="order">By Click</option>
        </select>
      </div>
      <div id="bad-list"></div>
    </div>
  </div>
</div>

<script>
(function() {
  let clips = [];
  let votes = { good: [], bad: [] };
  let selected = null;
  let sortOrder = null;   // null = default, or [{id, score}, ...]
  let sortMode = "text";  // "text" | "learned" | "load"
  let selectMode = "good"; // "good" | "hard"
  let threshold = null;    // threshold for Good/Bad boundary
  let sortTimer = null;
  let inclusion = 0;       // Inclusion setting: -10 to +10
  let loadedDetector = null; // Stores loaded detector model weights
  let datasetLoaded = false;
  let progressTimer = null;
  let goodSortMode = "clip"; // "clip" | "order"
  let badSortMode = "clip";  // "clip" | "order"

  const clipList = document.getElementById("clip-list");
  const center = document.getElementById("center");
  const goodList = document.getElementById("good-list");
  const badList = document.getElementById("bad-list");
  const goodSortSelect = document.getElementById("good-sort-mode");
  const badSortSelect = document.getElementById("bad-sort-mode");
  const textSortInput = document.getElementById("text-sort");
  const textSortWrap = document.getElementById("text-sort-wrap");
  const loadSortWrap = document.getElementById("load-sort-wrap");
  const loadDetectorBtn = document.getElementById("load-detector-btn");
  const loadDetectorFile = document.getElementById("load-detector-file");
  const learnedRadio = document.getElementById("learned-radio");
  const loadRadio = document.getElementById("load-radio");
  const sortStatus = document.getElementById("sort-status");
  const stripeOverview = document.getElementById("stripe-overview");
  const stripeContainer = document.getElementById("stripe-container");
  const inclusionSlider = document.getElementById("inclusion-slider");
  const inclusionValue = document.getElementById("inclusion-value");

  // Dataset management elements
  const datasetWelcome = document.getElementById("dataset-welcome");
  const datasetOptions = document.getElementById("dataset-options");
  const datasetProgress = document.getElementById("dataset-progress");
  const progressFill = document.getElementById("progress-fill");
  const progressText = document.getElementById("progress-text");
  const progressMessage = document.getElementById("progress-message");
  const demoDatasetsDiv = document.getElementById("demo-datasets");
  const backButton = document.getElementById("back-button");
  const loadFileBtn = document.getElementById("load-file-btn");
  const loadFolderBtn = document.getElementById("load-folder-btn");
  const loadDemoBtn = document.getElementById("load-demo-btn");
  const fileInput = document.getElementById("file-input");
  const folderInput = document.getElementById("folder-input");
  const datasetBar = document.getElementById("dataset-bar");
  const datasetInfo = document.getElementById("dataset-info");
  const leftPanel = document.getElementById("left-panel");
  const sortBar = document.getElementById("sort-bar");

  // Burger menu elements
  const burgerBtn = document.getElementById("burger-btn");
  const burgerDropdown = document.getElementById("burger-dropdown");
  const menuDatasetExport = document.getElementById("menu-dataset-export");
  const menuDatasetChange = document.getElementById("menu-dataset-change");
  const menuLabelsExport = document.getElementById("menu-labels-export");
  const menuLabelsImport = document.getElementById("menu-labels-import");
  const menuLabelsStatus = document.getElementById("menu-labels-status");
  const menuDetectorImport = document.getElementById("menu-detector-import");
  const menuDetectorExport = document.getElementById("menu-detector-export");
  const menuDetectorStatus = document.getElementById("menu-detector-status");

  // ---- Dataset Management ----

  async function checkDatasetStatus() {
    const res = await fetch("/api/dataset/status");
    const status = await res.json();
    datasetLoaded = status.loaded;

    if (datasetLoaded) {
      showMainUI();
      datasetInfo.textContent = `${status.num_clips} clips loaded`;
    } else {
      showWelcomeScreen();
    }

    return status;
  }

  function showWelcomeScreen() {
    datasetWelcome.style.display = "flex";
    center.className = "panel-center";
    datasetOptions.style.display = "flex";
    datasetProgress.style.display = "none";
    demoDatasetsDiv.style.display = "none";
    backButton.style.display = "none";
    sortBar.style.display = "none";
    datasetBar.style.display = "none";
    clipList.innerHTML = "";
  }

  function showMainUI() {
    datasetWelcome.style.display = "none";
    sortBar.style.display = "block";
    datasetBar.style.display = "flex";
    if (!selected) {
      center.className = "panel-center empty";
      center.innerHTML = "<p>Select a clip from the left panel</p>";
    }
  }

  function showProgress() {
    datasetOptions.style.display = "none";
    demoDatasetsDiv.style.display = "none";
    datasetProgress.style.display = "block";
    backButton.style.display = "none";
  }

  async function pollProgress() {
    const res = await fetch("/api/dataset/progress");
    const progress = await res.json();

    if (progress.error) {
      progressMessage.textContent = `Error: ${progress.error}`;
      progressMessage.style.color = "#f44336";
      stopProgressPolling();
      setTimeout(() => {
        showWelcomeScreen();
      }, 3000);
      return;
    }

    if (progress.status === "idle") {
      stopProgressPolling();
      await checkDatasetStatus();
      if (datasetLoaded) {
        await fetchClips();
        await fetchVotes();
      }
      return;
    }

    // Update progress bar
    let percentage = 0;
    if (progress.total > 0) {
      percentage = Math.round((progress.current / progress.total) * 100);
    }

    progressFill.style.width = `${percentage}%`;
    progressText.textContent = `${percentage}%`;
    progressMessage.textContent = progress.message || "Loading...";
    progressMessage.style.color = "#aaa";
  }

  function startProgressPolling() {
    if (progressTimer) return;
    showProgress();
    progressTimer = setInterval(pollProgress, 500);
  }

  function stopProgressPolling() {
    if (progressTimer) {
      clearInterval(progressTimer);
      progressTimer = null;
    }
  }

  // Load from file
  loadFileBtn.addEventListener("click", () => {
    fileInput.click();
  });

  fileInput.addEventListener("change", async () => {
    const file = fileInput.files[0];
    if (!file) return;

    const formData = new FormData();
    formData.append("file", file);

    startProgressPolling();

    try {
      const res = await fetch("/api/dataset/load-file", {
        method: "POST",
        body: formData,
      });

      if (!res.ok) {
        const error = await res.json();
        progressMessage.textContent = `Error: ${error.error}`;
        progressMessage.style.color = "#f44336";
        stopProgressPolling();
      }
    } catch (e) {
      progressMessage.textContent = `Error: ${e.message}`;
      progressMessage.style.color = "#f44336";
      stopProgressPolling();
    }

    fileInput.value = "";
  });

  // Load from folder (Note: folder selection requires server-side path input)
  loadFolderBtn.addEventListener("click", () => {
    const path = prompt("Enter the full path to the folder containing audio files:");
    if (!path) return;

    startProgressPolling();

    fetch("/api/dataset/load-folder", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ path }),
    }).then(res => {
      if (!res.ok) {
        res.json().then(error => {
          progressMessage.textContent = `Error: ${error.error}`;
          progressMessage.style.color = "#f44336";
          stopProgressPolling();
        });
      }
    }).catch(e => {
      progressMessage.textContent = `Error: ${e.message}`;
      progressMessage.style.color = "#f44336";
      stopProgressPolling();
    });
  });

  // Load demo dataset
  loadDemoBtn.addEventListener("click", async () => {
    datasetOptions.style.display = "none";
    demoDatasetsDiv.style.display = "grid";
    backButton.style.display = "block";

    // Fetch demo datasets
    try {
      const res = await fetch("/api/dataset/demo-list");
      if (!res.ok) {
        throw new Error(`Server returned ${res.status}`);
      }
      const data = await res.json();

      demoDatasetsDiv.innerHTML = "";
      data.datasets.forEach(dataset => {
      const div = document.createElement("div");
      div.className = "demo-dataset" + (dataset.ready ? " ready" : "");

      // Format file count
      const fileCountText = `${dataset.num_files} sound files`;

      // Format download size
      const sizeText = dataset.ready
        ? `${dataset.download_size_mb} MB (cached)`
        : `${dataset.download_size_mb} MB download`;

      div.innerHTML = `
        <h4>${dataset.name}</h4>
        <p style="margin: 4px 0; font-size: 0.85rem;">${fileCountText}</p>
        <p style="margin: 4px 0; font-size: 0.8rem; color: #888;">${dataset.num_categories} categories</p>
        <p style="margin: 4px 0; font-size: 0.8rem; color: #666;">${sizeText}</p>
        ${dataset.ready ? '<span class="ready-badge">Ready</span>' : '<span style="font-size:0.7rem;color:#888;">Needs download</span>'}
      `;
      div.onclick = () => loadDemo(dataset.name);
      demoDatasetsDiv.appendChild(div);
    });
    } catch (e) {
      demoDatasetsDiv.innerHTML = `<div style="color:#f44336; text-align:center;">Error loading demo datasets: ${e.message}</div>`;
    }
  });

  async function loadDemo(name) {
    startProgressPolling();

    try {
      const res = await fetch("/api/dataset/load-demo", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ name }),
      });

      if (!res.ok) {
        const error = await res.json();
        progressMessage.textContent = `Error: ${error.error}`;
        progressMessage.style.color = "#f44336";
        stopProgressPolling();
      }
    } catch (e) {
      progressMessage.textContent = `Error: ${e.message}`;
      progressMessage.style.color = "#f44336";
      stopProgressPolling();
    }
  }

  backButton.addEventListener("click", () => {
    showWelcomeScreen();
  });

  // ---- Burger Menu ----

  // Toggle burger menu
  burgerBtn.addEventListener("click", (e) => {
    e.stopPropagation();
    burgerDropdown.classList.toggle("show");
  });

  // Close burger menu when clicking outside
  document.addEventListener("click", (e) => {
    if (!burgerDropdown.contains(e.target) && !burgerBtn.contains(e.target)) {
      burgerDropdown.classList.remove("show");
    }
  });

  // Dataset export
  menuDatasetExport.addEventListener("click", () => {
    window.location.href = "/api/dataset/export";
    burgerDropdown.classList.remove("show");
  });

  // Dataset change
  menuDatasetChange.addEventListener("click", () => {
    if (confirm("Clear current dataset and load a new one?")) {
      fetch("/api/dataset/clear", { method: "POST" })
        .then(() => {
          showWelcomeScreen();
          clips = [];
          votes = { good: [], bad: [] };
          selected = null;
          datasetLoaded = false;
        });
    }
    burgerDropdown.classList.remove("show");
  });

  // Labels export
  menuLabelsExport.addEventListener("click", async () => {
    menuLabelsStatus.textContent = "";
    const res = await fetch("/api/labels/export");
    const data = await res.json();
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "labels.json";
    a.click();
    URL.revokeObjectURL(url);
    menuLabelsStatus.textContent = `Exported ${data.labels.length} labels`;
    setTimeout(() => { menuLabelsStatus.textContent = ""; }, 3000);
    burgerDropdown.classList.remove("show");
  });

  // Labels import
  menuLabelsImport.addEventListener("click", () => {
    importFile.click();
    burgerDropdown.classList.remove("show");
  });

  // Detector import
  menuDetectorImport.addEventListener("click", () => {
    loadDetectorFile.click();
    burgerDropdown.classList.remove("show");
  });

  // Detector export
  menuDetectorExport.addEventListener("click", async () => {
    menuDetectorStatus.textContent = "";
    if (votes.good.length === 0 || votes.bad.length === 0) {
      menuDetectorStatus.textContent = "Vote good & bad clips first";
      setTimeout(() => { menuDetectorStatus.textContent = ""; }, 3000);
      return;
    }
    menuDetectorStatus.textContent = "Exporting detector\u2026";
    const res = await fetch("/api/detector/export", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
    });
    if (!res.ok) {
      menuDetectorStatus.textContent = "Export failed";
      setTimeout(() => { menuDetectorStatus.textContent = ""; }, 3000);
      return;
    }
    const data = await res.json();
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "detector.json";
    a.click();
    URL.revokeObjectURL(url);
    menuDetectorStatus.textContent = "Detector exported";
    setTimeout(() => { menuDetectorStatus.textContent = ""; }, 3000);
    burgerDropdown.classList.remove("show");
  });

  // ---- Sort mode switching ----

  function updateSortModeAvailability() {
    const hasGoodAndBad = votes.good.length > 0 && votes.bad.length > 0;
    learnedRadio.disabled = !hasGoodAndBad;
    learnedRadio.parentElement.style.opacity = hasGoodAndBad ? "1" : "0.5";
    learnedRadio.parentElement.style.cursor = hasGoodAndBad ? "pointer" : "not-allowed";

    // Load radio is always enabled - selecting it prompts for detector file
    loadRadio.disabled = false;
    loadRadio.parentElement.style.opacity = "1";
    loadRadio.parentElement.style.cursor = "pointer";
  }

  document.querySelectorAll('input[name="sort-mode"]').forEach(radio => {
    radio.addEventListener("change", () => {
      // Validate selection
      if (radio.value === "learned" && (votes.good.length === 0 || votes.bad.length === 0)) {
        sortStatus.textContent = "Vote good & bad clips first";
        // Revert to text mode
        document.querySelector('input[name="sort-mode"][value="text"]').checked = true;
        return;
      }
      if (radio.value === "load") {
        // Immediately prompt to select a detector file
        sortMode = radio.value;
        textSortWrap.style.display = "none";
        loadSortWrap.style.display = "";
        sortStatus.textContent = "";
        // Trigger file picker
        loadDetectorFile.click();
        return;
      }

      sortMode = radio.value;
      textSortWrap.style.display = sortMode === "text" ? "" : "none";
      loadSortWrap.style.display = sortMode === "load" ? "" : "none";
      sortStatus.textContent = "";

      if (sortMode === "text") {
        onTextSortInput();
      } else if (sortMode === "learned") {
        fetchLearnedSort();
      }
    });
  });

  // ---- Select mode switching ----

  document.querySelectorAll('input[name="select-mode"]').forEach(radio => {
    radio.addEventListener("change", () => {
      selectMode = radio.value;
    });
  });

  // ---- Inclusion slider ----

  async function updateInclusion(newInclusion) {
    inclusion = newInclusion;
    inclusionValue.textContent = inclusion;

    // Save to server
    await fetch("/api/inclusion", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ inclusion }),
    });

    // Re-calculate threshold if in learned sort mode
    if (sortMode === "learned" && votes.good.length > 0 && votes.bad.length > 0) {
      await fetchLearnedSort();
    }
  }

  inclusionSlider.addEventListener("input", () => {
    updateInclusion(parseInt(inclusionSlider.value));
  });

  // ---- Good/Bad vote list sorting ----

  goodSortSelect.addEventListener("change", () => {
    goodSortMode = goodSortSelect.value;
    renderVotes();
  });

  badSortSelect.addEventListener("change", () => {
    badSortMode = badSortSelect.value;
    renderVotes();
  });

  // ---- Text sort ----

  async function fetchTextSort(text) {
    sortStatus.textContent = "Searching and sorting...";
    const res = await fetch("/api/sort", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ text }),
    });
    const data = await res.json();
    sortOrder = data.results.map(e => ({ id: e.id, score: e.similarity }));
    threshold = data.threshold;
    sortStatus.textContent = `Threshold: ${(threshold * 100).toFixed(1)}%`;
    renderClipList();
  }

  function onTextSortInput() {
    clearTimeout(sortTimer);
    const text = textSortInput.value.trim();
    if (!text) {
      sortOrder = null;
      sortStatus.textContent = "";
      renderClipList();
      return;
    }
    sortTimer = setTimeout(() => fetchTextSort(text), 400);
  }

  textSortInput.addEventListener("input", onTextSortInput);

  // ---- Learned sort ----

  async function fetchLearnedSort() {
    sortStatus.textContent = "Training\u2026";
    const res = await fetch("/api/learned-sort", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
    });
    if (!res.ok) {
      sortOrder = null;
      threshold = null;
      sortStatus.textContent = "Vote good & bad first";
      renderClipList();
      return;
    }
    const data = await res.json();
    sortOrder = data.results;  // [{id, score}, ...]
    threshold = data.threshold;
    sortStatus.textContent = `Threshold: ${(threshold * 100).toFixed(1)}%`;
    renderClipList();
  }

  // ---- Load detector sort ----

  async function fetchLoadedSort() {
    if (!loadedDetector) {
      sortStatus.textContent = "Load a detector first";
      return;
    }
    sortStatus.textContent = "Scoring with loaded detector\u2026";
    const res = await fetch("/api/detector-sort", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ detector: loadedDetector }),
    });
    if (!res.ok) {
      sortOrder = null;
      threshold = null;
      sortStatus.textContent = "Failed to score with detector";
      renderClipList();
      return;
    }
    const data = await res.json();
    sortOrder = data.results;  // [{id, score}, ...]
    threshold = data.threshold;
    sortStatus.textContent = `Threshold: ${(threshold * 100).toFixed(1)}%`;
    renderClipList();
  }

  // ---- Load detector file ----

  loadDetectorBtn.addEventListener("click", () => {
    loadDetectorFile.click();
  });

  loadDetectorFile.addEventListener("change", async () => {
    const file = loadDetectorFile.files[0];
    if (!file) {
      // User cancelled - revert to text mode if no detector loaded
      if (loadedDetector === null) {
        document.querySelector('input[name="sort-mode"][value="text"]').checked = true;
        sortMode = "text";
        textSortWrap.style.display = "";
        loadSortWrap.style.display = "none";
        sortStatus.textContent = "";
      }
      return;
    }
    sortStatus.textContent = "Loading detector\u2026";
    menuDetectorStatus.textContent = "Loading detector\u2026";
    const text = await file.text();
    try {
      loadedDetector = JSON.parse(text);
      sortStatus.textContent = "Detector loaded";
      menuDetectorStatus.textContent = "Detector loaded";
      setTimeout(() => { menuDetectorStatus.textContent = ""; }, 3000);
      updateSortModeAvailability();
      // Ensure load mode is selected
      document.querySelector('input[name="sort-mode"][value="load"]').checked = true;
      sortMode = "load";
      loadSortWrap.style.display = "";
      textSortWrap.style.display = "none";
      fetchLoadedSort();
    } catch (e) {
      sortStatus.textContent = "Invalid detector file";
      menuDetectorStatus.textContent = "Invalid detector file";
      setTimeout(() => { menuDetectorStatus.textContent = ""; }, 3000);
      loadedDetector = null;
      updateSortModeAvailability();
      // Revert to text mode on error
      document.querySelector('input[name="sort-mode"][value="text"]').checked = true;
      sortMode = "text";
      textSortWrap.style.display = "";
      loadSortWrap.style.display = "none";
    }
    loadDetectorFile.value = "";
  });

  // ---- Next Clip Selection ----

  function findNextClip() {
    if (!sortOrder || sortOrder.length === 0) {
      return null;
    }

    // Get unlabeled clips (not voted on)
    const unlabeled = sortOrder.filter(item => {
      return !votes.good.includes(item.id) && !votes.bad.includes(item.id);
    });

    if (unlabeled.length === 0) {
      return null;
    }

    let nextClip;
    if (selectMode === "good") {
      // Select highest scoring unlabeled clip
      nextClip = unlabeled[0];
    } else {
      // Select clip closest to threshold
      if (threshold === null) {
        return null;
      }
      let minDist = Infinity;
      for (const item of unlabeled) {
        const dist = Math.abs(item.score - threshold);
        if (dist < minDist) {
          minDist = dist;
          nextClip = item;
        }
      }
    }

    return nextClip;
  }

  // ---- Rendering ----

  async function fetchClips() {
    const res = await fetch("/api/clips");
    clips = await res.json();
    renderClipList();
  }

  async function fetchVotes() {
    const res = await fetch("/api/votes");
    votes = await res.json();
    renderVotes();
    renderStripe();
    updateSortModeAvailability();
    if (selected) renderCenter();
  }

  async function fetchInclusion() {
    const res = await fetch("/api/inclusion");
    const data = await res.json();
    inclusion = data.inclusion;
    inclusionSlider.value = inclusion;
    inclusionValue.textContent = inclusion;
  }

  function renderClipList() {
    clipList.innerHTML = "";
    const scoreMap = {};
    if (sortOrder) {
      sortOrder.forEach(s => { scoreMap[s.id] = s.score; });
    }

    let ordered;
    if (sortOrder) {
      ordered = sortOrder.map(s => clips.find(c => c.id === s.id)).filter(Boolean);
    } else {
      ordered = clips;
    }

    ordered.forEach(c => {
      const div = document.createElement("div");
      const isGood = votes.good.includes(c.id);
      const isBad = votes.bad.includes(c.id);
      let className = "clip-item";
      if (selected === c.id) className += " active";
      if (isGood) className += " labeled-good";
      if (isBad) className += " labeled-bad";
      div.className = className;
      let html = `<div style="font-weight: 500;">${c.filename || 'Clip #' + c.id}</div>`;
      if (scoreMap[c.id] !== undefined) {
        html += `<span class="sim">${(scoreMap[c.id] * 100).toFixed(1)}%</span>`;
      }
      let subInfo = [];
      if (c.frequency) {
        subInfo.push(`${c.frequency} Hz`);
      }
      if (c.category && c.category !== "unknown") {
        subInfo.push(c.category);
      }
      subInfo.push(`${c.duration.toFixed(1)}s`);
      html += `<div class="sub">${subInfo.join(' &middot; ')}</div>`;
      div.innerHTML = html;
      div.onclick = () => selectClip(c.id);
      clipList.appendChild(div);
    });

    renderStripe();
  }

  function selectClip(id) {
    selected = id;
    renderClipList();
    renderCenter();
  }

  function renderCenter() {
    const c = clips.find(x => x.id === selected);
    if (!c) return;
    const isGood = votes.good.includes(c.id);
    const isBad = votes.bad.includes(c.id);
    center.className = "panel-center";

    let metaInfo = [];
    if (c.frequency) {
      metaInfo.push(`${c.frequency} Hz`);
    }
    if (c.category && c.category !== "unknown") {
      metaInfo.push(c.category);
    }
    metaInfo.push(`${c.duration.toFixed(1)}s`);
    metaInfo.push(`${(c.file_size / 1024).toFixed(1)} KB`);

    center.innerHTML = `
      <div class="meta">
        <h2>${c.filename || 'Clip #' + c.id}</h2>
        <p>${metaInfo.join(' &middot; ')}</p>
      </div>
      <canvas id="waveform-canvas" width="600" height="120"></canvas>
      <audio controls loop autoplay src="/api/clips/${c.id}/audio" id="clip-audio"></audio>
      <div class="metadata-grid">
        ${c.frequency ? `
        <div class="metadata-item">
          <span class="metadata-label">Frequency</span>
          <span class="metadata-value">${c.frequency} Hz</span>
        </div>` : ''}
        ${c.category && c.category !== 'unknown' ? `
        <div class="metadata-item">
          <span class="metadata-label">Category</span>
          <span class="metadata-value">${c.category}</span>
        </div>` : ''}
        <div class="metadata-item">
          <span class="metadata-label">Duration</span>
          <span class="metadata-value">${c.duration.toFixed(1)}s</span>
        </div>
        <div class="metadata-item">
          <span class="metadata-label">File Size</span>
          <span class="metadata-value">${(c.file_size / 1024).toFixed(1)} KB</span>
        </div>
        <div class="metadata-item">
          <span class="metadata-label">Filename</span>
          <span class="metadata-value">${c.filename || 'clip_' + c.id + '.wav'}</span>
        </div>
        <div class="metadata-item">
          <span class="metadata-label">MD5</span>
          <span class="metadata-value metadata-md5">${c.md5}</span>
        </div>
      </div>
      <div class="vote-buttons">
        <button class="btn-bad${isBad ? " voted" : ""}" id="vote-bad">Bad</button>
        <button class="btn-good${isGood ? " voted" : ""}" id="vote-good">Good</button>
      </div>`;
    document.getElementById("vote-good").onclick = () => castVote(c.id, "good");
    document.getElementById("vote-bad").onclick = () => castVote(c.id, "bad");

    // Draw waveform
    drawWaveform(c.id);
  }

  async function castVote(id, vote) {
    await fetch(`/api/clips/${id}/vote`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ vote }),
    });
    await fetchVotes();
    if (sortMode === "learned") await fetchLearnedSort();

    // Auto-advance to next clip
    const nextClip = findNextClip();
    if (nextClip) {
      selectClip(nextClip.id);
    }
  }

  async function drawWaveform(clipId) {
    const canvas = document.getElementById("waveform-canvas");
    if (!canvas) return;

    const ctx = canvas.getContext("2d");
    const width = canvas.width;
    const height = canvas.height;

    // Clear canvas
    ctx.fillStyle = "#1a1d27";
    ctx.fillRect(0, 0, width, height);

    try {
      // Fetch audio data
      const response = await fetch(`/api/clips/${clipId}/audio`);
      const arrayBuffer = await response.arrayBuffer();

      // Decode audio data
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

      // Get audio data from first channel
      const channelData = audioBuffer.getChannelData(0);
      const step = Math.ceil(channelData.length / width);
      const amp = height / 2;

      // Draw waveform
      ctx.strokeStyle = "#7c8aff";
      ctx.lineWidth = 1;
      ctx.beginPath();

      for (let i = 0; i < width; i++) {
        let min = 1.0;
        let max = -1.0;

        for (let j = 0; j < step; j++) {
          const datum = channelData[i * step + j];
          if (datum < min) min = datum;
          if (datum > max) max = datum;
        }

        const yMin = (1 + min) * amp;
        const yMax = (1 + max) * amp;

        if (i === 0) {
          ctx.moveTo(i, yMin);
        }
        ctx.lineTo(i, yMin);
        ctx.lineTo(i, yMax);
      }

      ctx.stroke();

      // Draw center line
      ctx.strokeStyle = "#2a2d3a";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(0, height / 2);
      ctx.lineTo(width, height / 2);
      ctx.stroke();

    } catch (error) {
      console.error("Error drawing waveform:", error);
      // Draw error message
      ctx.fillStyle = "#f44336";
      ctx.font = "12px monospace";
      ctx.textAlign = "center";
      ctx.fillText("Unable to load waveform", width / 2, height / 2);
    }
  }

  function renderVotes() {
    goodList.innerHTML = "";
    badList.innerHTML = "";

    // Sort good votes based on selected mode
    const sortedGood = goodSortMode === "clip"
      ? [...votes.good].sort((a, b) => a - b)  // By clip# (numerical)
      : [...votes.good];  // By click order (insertion order)

    sortedGood.forEach(id => {
      const div = document.createElement("div");
      div.className = "vote-entry";
      div.textContent = `Clip #${id}`;
      div.onclick = () => selectClip(id);
      goodList.appendChild(div);
    });

    // Sort bad votes based on selected mode
    const sortedBad = badSortMode === "clip"
      ? [...votes.bad].sort((a, b) => a - b)  // By clip# (numerical)
      : [...votes.bad];  // By click order (insertion order)

    sortedBad.forEach(id => {
      const div = document.createElement("div");
      div.className = "vote-entry";
      div.textContent = `Clip #${id}`;
      div.onclick = () => selectClip(id);
      badList.appendChild(div);
    });
  }

  function renderStripe() {
    stripeContainer.innerHTML = "";

    // Only show stripe when sorted
    if (!sortOrder || sortOrder.length === 0) {
      stripeOverview.style.display = "none";
      return;
    }

    stripeOverview.style.display = "block";
    const totalClips = sortOrder.length;

    // Render dots for each labeled clip
    sortOrder.forEach((item, index) => {
      const isGood = votes.good.includes(item.id);
      const isBad = votes.bad.includes(item.id);

      if (isGood || isBad) {
        const dot = document.createElement("div");
        dot.className = `stripe-dot ${isGood ? "good" : "bad"}`;
        dot.style.top = `${(index / totalClips) * 100}%`;
        dot.setAttribute("data-clip-id", item.id);
        dot.setAttribute("data-index", index);
        stripeContainer.appendChild(dot);
      }
    });

    // Render threshold line if available
    if (threshold !== null) {
      // Find the index where score crosses threshold
      let thresholdIndex = 0;
      for (let i = 0; i < sortOrder.length; i++) {
        if (sortOrder[i].score < threshold) {
          thresholdIndex = i;
          break;
        }
      }

      const thresholdLine = document.createElement("div");
      thresholdLine.className = "stripe-threshold";
      thresholdLine.style.top = `${(thresholdIndex / totalClips) * 100}%`;
      stripeContainer.appendChild(thresholdLine);
    }
  }

  // ---- Stripe click handler ----

  stripeOverview.addEventListener("click", (e) => {
    if (!sortOrder || sortOrder.length === 0) return;

    const rect = stripeOverview.getBoundingClientRect();
    const y = e.clientY - rect.top;
    const percentage = y / rect.height;
    const index = Math.floor(percentage * sortOrder.length);
    const clampedIndex = Math.max(0, Math.min(index, sortOrder.length - 1));

    if (sortOrder[clampedIndex]) {
      const clipId = sortOrder[clampedIndex].id;
      selectClip(clipId);

      // Scroll the clip into view
      const clipItems = clipList.querySelectorAll(".clip-item");
      if (clipItems[clampedIndex]) {
        clipItems[clampedIndex].scrollIntoView({ behavior: "smooth", block: "center" });
      }
    }
  });

  // ---- Label import handler ----

  const importFile = document.getElementById("import-file");

  importFile.addEventListener("change", async () => {
    const file = importFile.files[0];
    if (!file) return;
    menuLabelsStatus.textContent = "Importing\u2026";
    const text = await file.text();
    let data;
    try {
      data = JSON.parse(text);
    } catch (e) {
      menuLabelsStatus.textContent = "Invalid JSON file";
      setTimeout(() => { menuLabelsStatus.textContent = ""; }, 3000);
      importFile.value = "";
      return;
    }
    const res = await fetch("/api/labels/import", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(data),
    });
    const result = await res.json();
    if (res.ok) {
      menuLabelsStatus.textContent = `Applied ${result.applied}, skipped ${result.skipped}`;
      await fetchVotes();
      setTimeout(() => { menuLabelsStatus.textContent = ""; }, 3000);
    } else {
      menuLabelsStatus.textContent = result.error || "Import failed";
      setTimeout(() => { menuLabelsStatus.textContent = ""; }, 3000);
    }
    importFile.value = "";
  });

  // Initialize
  checkDatasetStatus();
  fetchInclusion();
})();
</script>
</body>
</html>
