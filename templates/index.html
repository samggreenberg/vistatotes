<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>VectoryTones</title>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background: #0f1117; color: #e0e0e0; height: 100vh; display: flex; flex-direction: column; }
  header { background: #1a1d27; padding: 12px 24px; border-bottom: 1px solid #2a2d3a; display: flex; align-items: center; gap: 12px; }
  header h1 { font-size: 1.3rem; color: #7c8aff; }
  header span { font-size: 0.85rem; color: #888; }
  .layout { display: flex; flex: 1; overflow: hidden; }

  /* Left panel – clip list */
  .panel-left { width: 240px; border-right: 1px solid #2a2d3a; overflow-y: auto; background: #14161e; display: flex; flex-direction: column; position: relative; }
  .panel-left h2 { font-size: 0.85rem; text-transform: uppercase; letter-spacing: 0.05em; color: #888; padding: 12px 16px 8px; }
  .sort-bar { padding: 8px 16px 12px; border-bottom: 1px solid #2a2d3a; }
  .sort-mode { display: flex; gap: 10px; margin-bottom: 6px; }
  .sort-mode label { font-size: 0.75rem; color: #aaa; cursor: pointer; display: flex; align-items: center; gap: 3px; }
  .sort-mode input[type="radio"] { accent-color: #7c8aff; margin: 0; }
  .sort-bar .sort-label { font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.05em; color: #888; display: block; margin-bottom: 4px; }
  .sort-bar input[type="text"] { width: 100%; padding: 6px 8px; border: 1px solid #2a2d3a; border-radius: 4px; background: #1a1d27; color: #e0e0e0; font-size: 0.85rem; outline: none; }
  .sort-bar input[type="text"]:focus { border-color: #7c8aff; }
  .sort-bar input[type="text"]::placeholder { color: #555; }
  .sort-bar .sort-status { font-size: 0.7rem; color: #666; margin-top: 4px; }
  #clip-list { overflow-y: auto; flex: 1; }
  .clip-item { padding: 10px 16px; cursor: pointer; font-size: 0.9rem; border-bottom: 1px solid #1e2030; transition: background 0.15s; }
  .clip-item:hover { background: #1e2030; }
  .clip-item.active { background: #252940; color: #7c8aff; }
  .clip-item .sub { font-size: 0.75rem; color: #666; margin-top: 2px; }
  .clip-item .sim { font-size: 0.7rem; color: #7c8aff; float: right; margin-top: 2px; }

  /* Stripe overview */
  .stripe-overview { position: absolute; right: 0; top: 0; bottom: 0; width: 20px; background: #1a1d27; border-left: 1px solid #2a2d3a; cursor: pointer; }
  .stripe-container { position: relative; height: 100%; }
  .stripe-dot { position: absolute; left: 50%; width: 6px; height: 6px; border-radius: 50%; transform: translateX(-50%); }
  .stripe-dot.good { background: #4caf50; }
  .stripe-dot.bad { background: #f44336; }
  .stripe-threshold { position: absolute; left: 0; right: 0; height: 2px; background: #7c8aff; }
  .stripe-threshold::before { content: ''; position: absolute; left: 0; top: 50%; transform: translateY(-50%); width: 0; height: 0; border-top: 4px solid transparent; border-bottom: 4px solid transparent; border-left: 6px solid #7c8aff; }
  .stripe-threshold::after { content: ''; position: absolute; right: 0; top: 50%; transform: translateY(-50%); width: 0; height: 0; border-top: 4px solid transparent; border-bottom: 4px solid transparent; border-right: 6px solid #7c8aff; }

  /* Center panel – player */
  .panel-center { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 20px; padding: 32px; }
  .panel-center.empty { color: #555; font-size: 1rem; }
  .meta { text-align: center; }
  .meta h2 { font-size: 1.5rem; color: #7c8aff; margin-bottom: 8px; }
  .meta p { font-size: 0.85rem; color: #888; margin: 2px 0; }
  audio { width: 320px; }
  .vote-buttons { display: flex; gap: 16px; }
  .vote-buttons button { padding: 10px 28px; border: 2px solid; border-radius: 8px; font-size: 1rem; cursor: pointer; background: transparent; transition: all 0.15s; }
  .btn-good { color: #4caf50; border-color: #4caf50; }
  .btn-good:hover, .btn-good.voted { background: #4caf50; color: #fff; }
  .btn-bad { color: #f44336; border-color: #f44336; }
  .btn-bad:hover, .btn-bad.voted { background: #f44336; color: #fff; }

  /* Right panel – votes */
  .panel-right { width: 240px; border-left: 1px solid #2a2d3a; overflow-y: auto; background: #14161e; display: flex; flex-direction: column; }
  .vote-section { flex: 1; overflow-y: auto; padding: 12px 16px; }
  .vote-section + .vote-section { border-top: 1px solid #2a2d3a; }
  .vote-section h3 { font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 8px; }
  .vote-section h3.good { color: #4caf50; }
  .vote-section h3.bad { color: #f44336; }
  .vote-entry { padding: 6px 0; font-size: 0.85rem; cursor: pointer; color: #bbb; }
  .vote-entry:hover { color: #fff; }

  /* Import/Export bar */
  .label-io { display: flex; gap: 8px; padding: 12px 16px; border-bottom: 1px solid #2a2d3a; }
  .label-io button { flex: 1; padding: 6px 0; border: 1px solid #2a2d3a; border-radius: 4px; background: #1a1d27; color: #aaa; font-size: 0.75rem; cursor: pointer; transition: background 0.15s, color 0.15s; }
  .label-io button:hover { background: #252940; color: #e0e0e0; }
  .label-io-status { font-size: 0.7rem; color: #666; padding: 0 16px 8px; }
</style>
</head>
<body>
<header>
  <h1>VectoryTones</h1>
  <span>Sound clip explorer with vector embeddings</span>
</header>
<div class="layout">
  <!-- Left panel -->
  <div class="panel-left">
    <h2>Clips</h2>
    <div class="sort-bar">
      <span class="sort-label">Sort</span>
      <div class="sort-mode">
        <label><input type="radio" name="sort-mode" value="none" checked> None</label>
        <label><input type="radio" name="sort-mode" value="text"> Text</label>
        <label><input type="radio" name="sort-mode" value="learned"> Learn</label>
      </div>
      <div id="text-sort-wrap" style="display:none">
        <input type="text" id="text-sort" placeholder='e.g. "high pitched beep"'>
      </div>
      <span class="sort-label" style="margin-top:8px">Select</span>
      <div class="sort-mode">
        <label><input type="radio" name="select-mode" value="good" checked> Good</label>
        <label><input type="radio" name="select-mode" value="hard"> Hard</label>
      </div>
      <button id="next-clip-btn" style="width:100%; margin-top:8px; padding:6px; background:#7c8aff; color:#fff; border:none; border-radius:4px; cursor:pointer; font-size:0.85rem;">Next Clip</button>
      <div id="sort-status" class="sort-status"></div>
    </div>
    <div id="clip-list"></div>
    <div class="stripe-overview" id="stripe-overview">
      <div class="stripe-container" id="stripe-container"></div>
    </div>
  </div>

  <!-- Center panel -->
  <div class="panel-center empty" id="center">
    <p>Select a clip from the left panel</p>
  </div>

  <!-- Right panel -->
  <div class="panel-right">
    <div class="label-io">
      <button id="export-btn">Export Labels</button>
      <button id="import-btn">Import Labels</button>
      <input type="file" id="import-file" accept=".json" style="display:none">
    </div>
    <div id="label-io-status" class="label-io-status"></div>
    <div class="vote-section">
      <h3 class="good">Good</h3>
      <div id="good-list"></div>
    </div>
    <div class="vote-section">
      <h3 class="bad">Bad</h3>
      <div id="bad-list"></div>
    </div>
  </div>
</div>

<script>
(function() {
  let clips = [];
  let votes = { good: [], bad: [] };
  let selected = null;
  let sortOrder = null;   // null = default, or [{id, score}, ...]
  let sortMode = "none";  // "none" | "text" | "learned"
  let selectMode = "good"; // "good" | "hard"
  let threshold = null;    // threshold for Good/Bad boundary
  let sortTimer = null;

  const clipList = document.getElementById("clip-list");
  const center = document.getElementById("center");
  const goodList = document.getElementById("good-list");
  const badList = document.getElementById("bad-list");
  const textSortInput = document.getElementById("text-sort");
  const textSortWrap = document.getElementById("text-sort-wrap");
  const sortStatus = document.getElementById("sort-status");
  const nextClipBtn = document.getElementById("next-clip-btn");
  const stripeOverview = document.getElementById("stripe-overview");
  const stripeContainer = document.getElementById("stripe-container");

  // ---- Sort mode switching ----

  document.querySelectorAll('input[name="sort-mode"]').forEach(radio => {
    radio.addEventListener("change", () => {
      sortMode = radio.value;
      textSortWrap.style.display = sortMode === "text" ? "" : "none";
      sortStatus.textContent = "";
      if (sortMode === "none") {
        sortOrder = null;
        threshold = null;
        renderClipList();
      } else if (sortMode === "text") {
        onTextSortInput();
      } else if (sortMode === "learned") {
        fetchLearnedSort();
      }
    });
  });

  // ---- Select mode switching ----

  document.querySelectorAll('input[name="select-mode"]').forEach(radio => {
    radio.addEventListener("change", () => {
      selectMode = radio.value;
    });
  });

  // ---- Text sort ----

  async function fetchTextSort(text) {
    const res = await fetch("/api/sort", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ text }),
    });
    const data = await res.json();
    sortOrder = data.results.map(e => ({ id: e.id, score: e.similarity }));
    threshold = data.threshold;
    sortStatus.textContent = `Threshold: ${(threshold * 100).toFixed(1)}%`;
    renderClipList();
  }

  function onTextSortInput() {
    clearTimeout(sortTimer);
    const text = textSortInput.value.trim();
    if (!text) {
      sortOrder = null;
      renderClipList();
      return;
    }
    sortTimer = setTimeout(() => fetchTextSort(text), 400);
  }

  textSortInput.addEventListener("input", onTextSortInput);

  // ---- Learned sort ----

  async function fetchLearnedSort() {
    sortStatus.textContent = "Training\u2026";
    const res = await fetch("/api/learned-sort", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
    });
    if (!res.ok) {
      sortOrder = null;
      threshold = null;
      sortStatus.textContent = "Vote good & bad first";
      renderClipList();
      return;
    }
    const data = await res.json();
    sortOrder = data.results;  // [{id, score}, ...]
    threshold = data.threshold;
    sortStatus.textContent = `Threshold: ${(threshold * 100).toFixed(1)}%`;
    renderClipList();
  }

  // ---- Next Clip Selection ----

  nextClipBtn.addEventListener("click", () => {
    if (!sortOrder || sortOrder.length === 0) {
      sortStatus.textContent = "Sort clips first";
      return;
    }

    // Get unlabeled clips (not voted on)
    const unlabeled = sortOrder.filter(item => {
      return !votes.good.includes(item.id) && !votes.bad.includes(item.id);
    });

    if (unlabeled.length === 0) {
      sortStatus.textContent = "All clips labeled";
      return;
    }

    let nextClip;
    if (selectMode === "good") {
      // Select highest scoring unlabeled clip
      nextClip = unlabeled[0];
    } else {
      // Select clip closest to threshold
      if (threshold === null) {
        sortStatus.textContent = "No threshold available";
        return;
      }
      let minDist = Infinity;
      for (const item of unlabeled) {
        const dist = Math.abs(item.score - threshold);
        if (dist < minDist) {
          minDist = dist;
          nextClip = item;
        }
      }
    }

    if (nextClip) {
      selectClip(nextClip.id);
    }
  });

  // ---- Rendering ----

  async function fetchClips() {
    const res = await fetch("/api/clips");
    clips = await res.json();
    renderClipList();
  }

  async function fetchVotes() {
    const res = await fetch("/api/votes");
    votes = await res.json();
    renderVotes();
    renderStripe();
    if (selected) renderCenter();
  }

  function renderClipList() {
    clipList.innerHTML = "";
    const scoreMap = {};
    if (sortOrder) {
      sortOrder.forEach(s => { scoreMap[s.id] = s.score; });
    }

    let ordered;
    if (sortOrder) {
      ordered = sortOrder.map(s => clips.find(c => c.id === s.id)).filter(Boolean);
    } else {
      ordered = clips;
    }

    ordered.forEach(c => {
      const div = document.createElement("div");
      div.className = "clip-item" + (selected === c.id ? " active" : "");
      let html = `Clip #${c.id}`;
      if (scoreMap[c.id] !== undefined) {
        html += `<span class="sim">${(scoreMap[c.id] * 100).toFixed(1)}%</span>`;
      }
      html += `<div class="sub">${c.frequency} Hz &middot; ${c.duration}s</div>`;
      div.innerHTML = html;
      div.onclick = () => selectClip(c.id);
      clipList.appendChild(div);
    });

    renderStripe();
  }

  function selectClip(id) {
    selected = id;
    renderClipList();
    renderCenter();
  }

  function renderCenter() {
    const c = clips.find(x => x.id === selected);
    if (!c) return;
    const isGood = votes.good.includes(c.id);
    const isBad = votes.bad.includes(c.id);
    center.className = "panel-center";
    center.innerHTML = `
      <div class="meta">
        <h2>Clip #${c.id}</h2>
        <p>${c.frequency} Hz &middot; ${c.duration}s &middot; ${(c.file_size / 1024).toFixed(1)} KB</p>
      </div>
      <audio controls loop autoplay src="/api/clips/${c.id}/audio"></audio>
      <div class="vote-buttons">
        <button class="btn-good${isGood ? " voted" : ""}" id="vote-good">Good</button>
        <button class="btn-bad${isBad ? " voted" : ""}" id="vote-bad">Bad</button>
      </div>`;
    document.getElementById("vote-good").onclick = () => castVote(c.id, "good");
    document.getElementById("vote-bad").onclick = () => castVote(c.id, "bad");
  }

  async function castVote(id, vote) {
    await fetch(`/api/clips/${id}/vote`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ vote }),
    });
    await fetchVotes();
    if (sortMode === "learned") fetchLearnedSort();
  }

  function renderVotes() {
    goodList.innerHTML = "";
    badList.innerHTML = "";
    votes.good.forEach(id => {
      const div = document.createElement("div");
      div.className = "vote-entry";
      div.textContent = `Clip #${id}`;
      div.onclick = () => selectClip(id);
      goodList.appendChild(div);
    });
    votes.bad.forEach(id => {
      const div = document.createElement("div");
      div.className = "vote-entry";
      div.textContent = `Clip #${id}`;
      div.onclick = () => selectClip(id);
      badList.appendChild(div);
    });
  }

  function renderStripe() {
    stripeContainer.innerHTML = "";

    // Only show stripe when sorted
    if (!sortOrder || sortOrder.length === 0) {
      stripeOverview.style.display = "none";
      return;
    }

    stripeOverview.style.display = "block";
    const totalClips = sortOrder.length;

    // Render dots for each labeled clip
    sortOrder.forEach((item, index) => {
      const isGood = votes.good.includes(item.id);
      const isBad = votes.bad.includes(item.id);

      if (isGood || isBad) {
        const dot = document.createElement("div");
        dot.className = `stripe-dot ${isGood ? "good" : "bad"}`;
        dot.style.top = `${(index / totalClips) * 100}%`;
        dot.setAttribute("data-clip-id", item.id);
        dot.setAttribute("data-index", index);
        stripeContainer.appendChild(dot);
      }
    });

    // Render threshold line if available
    if (threshold !== null) {
      // Find the index where score crosses threshold
      let thresholdIndex = 0;
      for (let i = 0; i < sortOrder.length; i++) {
        if (sortOrder[i].score < threshold) {
          thresholdIndex = i;
          break;
        }
      }

      const thresholdLine = document.createElement("div");
      thresholdLine.className = "stripe-threshold";
      thresholdLine.style.top = `${(thresholdIndex / totalClips) * 100}%`;
      stripeContainer.appendChild(thresholdLine);
    }
  }

  // ---- Stripe click handler ----

  stripeOverview.addEventListener("click", (e) => {
    if (!sortOrder || sortOrder.length === 0) return;

    const rect = stripeOverview.getBoundingClientRect();
    const y = e.clientY - rect.top;
    const percentage = y / rect.height;
    const index = Math.floor(percentage * sortOrder.length);
    const clampedIndex = Math.max(0, Math.min(index, sortOrder.length - 1));

    if (sortOrder[clampedIndex]) {
      const clipId = sortOrder[clampedIndex].id;
      selectClip(clipId);

      // Scroll the clip into view
      const clipItems = clipList.querySelectorAll(".clip-item");
      if (clipItems[clampedIndex]) {
        clipItems[clampedIndex].scrollIntoView({ behavior: "smooth", block: "center" });
      }
    }
  });

  // ---- Label export / import ----

  const exportBtn = document.getElementById("export-btn");
  const importBtn = document.getElementById("import-btn");
  const importFile = document.getElementById("import-file");
  const labelIoStatus = document.getElementById("label-io-status");

  exportBtn.addEventListener("click", async () => {
    labelIoStatus.textContent = "";
    const res = await fetch("/api/labels/export");
    const data = await res.json();
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "labels.json";
    a.click();
    URL.revokeObjectURL(url);
    labelIoStatus.textContent = `Exported ${data.labels.length} labels`;
  });

  importBtn.addEventListener("click", () => {
    importFile.click();
  });

  importFile.addEventListener("change", async () => {
    const file = importFile.files[0];
    if (!file) return;
    labelIoStatus.textContent = "Importing\u2026";
    const text = await file.text();
    let data;
    try {
      data = JSON.parse(text);
    } catch (e) {
      labelIoStatus.textContent = "Invalid JSON file";
      importFile.value = "";
      return;
    }
    const res = await fetch("/api/labels/import", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(data),
    });
    const result = await res.json();
    if (res.ok) {
      labelIoStatus.textContent = `Applied ${result.applied}, skipped ${result.skipped}`;
      await fetchVotes();
    } else {
      labelIoStatus.textContent = result.error || "Import failed";
    }
    importFile.value = "";
  });

  fetchClips();
  fetchVotes();
})();
</script>
</body>
</html>
